## 程序执行的主要顺序

1. ​**编写源代码**​（开发阶段）。
2. ​**编译源代码**​（编译阶段）。
3. ​**链接可执行文件**​（链接阶段）。输出是一个完整的可执行文件（例如 `.exe`、`a.out`）。
4. ​**加载程序到内存**​（加载阶段）。
5. ​**程序执行**​（执行阶段）。
   * 调用 `main()` 函数。
   * 执行程序的指令。
   * 函数调用，栈、堆内存分配。
   * 异常处理。
6. ​**程序退出**​（退出阶段）。
   * 执行清理工作，析构函数。
   * 释放内存，退出程序。

### 宏的处理通常发生在 ​**编译阶段**​，但更具体地说，是在 ​**预处理阶段**​。预处理是编译的第一步，**预处理阶段**会进行宏替换、文件包含等操作

## ​**const和constexpr**

* `const`​：用于声明值不可修改的变量或指针。可以在运行时初始化。
* ​`constexpr`：用于声明在编译时就已确定的常量或常量表达式。函数也可以是 `constexpr`，表示它们可以在编译时计算结果。

## **指针和引用的区别**

### **引用（Reference）**：

- 是对象的别名，必须在声明时初始化。
- 不能为 `nullptr`，一旦绑定到某个对象，就不能再绑定其他对象。
- 语法简单，直接使用，不需要解引用。
- 通常用在函数参数传递时，确保不复制数据且能修改原始对象。

### **指针（Pointer）**：

- 存储对象的地址，可以为空（`nullptr`）。
- 可以改变指向的对象。
- 需要解引用（`*`）来访问对象。
- 可以用于动态内存分配。

## ​**new和delete操作符**

* **`new`** 用于动态分配内存并调用构造函数。
* **`delete`** 用于释放通过 `new` 分配的单个对象的内存，并调用析构函数。
* 对于数组，使用 **`new[]`** 来分配内存，并使用 **`delete[]`** 来释放内存。
* 手动使用 `new` 和 `delete` 需要谨慎管理内存，以防止内存泄漏和其他错误。

## `static` 关键字的作用：

1. ​**局部静态变量**​：
   * 在函数内声明的静态变量，其生命周期延长至程序结束，但作用域仅限于该函数。
   * 只初始化一次，后续调用保持值。
2. ​**静态成员变量**​：
   * 属于类的共享成员，所有对象共享同一个静态成员变量。
3. ​**静态成员函数**​：
   * 只能访问静态成员变量和静态成员函数，可以通过类名直接调用，如`MyClass::count`
4. ​**静态全局变量**​：
   * 限制变量的作用域仅在当前文件内，避免外部访问。

总结：`static` 用来延长生命周期、共享数据或限制作用域。

## ​**构造函数与析构函数**​

* ​​**析构函数**​：在对象创建时自动调用，初始化对象的状态。
* ​**析构函数**​：在对象销毁时自动调用，释放资源，防止资源泄漏。

## ​**深浅拷贝**

* ​**浅拷贝**​：拷贝的是对象的指针，多个对象共享同一块内存，可能导致资源管理问题（如内存泄漏或悬空指针）。
* ​**深拷贝**​：拷贝对象及其指针指向的内容，确保每个对象有独立的内存空间，避免互相影响

## ​**C++ 中的拷贝构造函数和赋值操作符有什么区别**

> ### 拷贝构造函数

* 定义：拷贝构造函数是用于**创建**一个对象为另一个同类型对象的副本时自动调用的构造函数。(浅拷贝)
* 语法：`ClassName(const ClassName& other);

```C++
class MyClass {
public:
   int data;
   MyClass(int d) : data(d) {}
   MyClass(const MyClass& other) {  // 拷贝构造函数
     data = other.data;
   }
};

int main() {
   MyClass obj1(10);  // 创建对象 obj1
   MyClass obj2 = obj1;  // 调用拷贝构造函数
   return 0;
}
```

> ### 赋值操作符

​**赋值给已存在的对象**​：赋值操作符在已有对象间赋值时非常常见。比如：* 在对象已经存在时，将一个对象赋值给另一个对象。

* 赋值操作符还用于链式赋值（例如，`a = b = c;`）

```C++
MyClass obj1(10);  // 创建 obj1
MyClass obj2(20);  // 创建 obj2
obj2 = obj1;  // 调用赋值操作符，将 obj1 的内容赋给 obj2
```




## **`*obj3->ptr`**:先指针运算符，再解引用

## 智能指针

### 1. 智能指针的基本概念

智能指针是C++11标准引入的工具，是一种封装了指针和资源管理功能的对象。与传统的原始指针（raw pointer）不同，智能指针在其自身被销毁时会自动释放它所指向的对象。这种机制可以有效防止内存泄漏，并在异常情况下确保资源自动释放，避免手动管理内存的潜在失误。

### 2. 常见的智能指针类型

unique_ptr、shared_ptr、weak_ptr

> unique_ptr

+ 独占所有权，不允许复制
+ 它的主要特性是​**唯一所有权**​，即一个对象只能有一个 `unique_ptr` 指向它，所以其不可复制，可以使用 **移动语义**将 `unique_ptr` 的所有权转移给另一个 `unique_ptr`，（在`unique_ptr` 的生命周期结束时，它所管理的对象会自动释放，从而避免内存泄漏。）
+ 创建：`unique_ptr<int> ptr = make_unique<int>(10);`

> shared_ptr

+ 共享所有权，引用计数，需要避免循环引用问题，可以使用 `weak_ptr` 来打破循环引用。
+ **循环引用** 是 `shared_ptr` 使用中的一个常见问题，它发生在两个或多个 `shared_ptr` 互相引用，从而导致引用计数永远不为 0，导致内存泄漏。
+ `weak_ptr` 是解决循环引用问题的工具，它不会增加引用计数，因此可以打破循环引用
+ 与 `unique_ptr` 不同，`shared_ptr`允许多个指针共享对同一资源（对象）的所有权， 允许复制，内部有引用计数机制，跟踪有多少个`shared_ptr`指向对象， 当最后一个`shared_ptr`销毁时才释放对象。
+ `shared_ptr<int> ptr = :make_shared<int>(10);`

## **继承**

| 基类成员           | 公有继承（`public`） | 保护继承（`protected`）  | 私有继承（`private`）    |
| -------------------- | -------------------------- | ------------------------------ | ------------------------------ |
| **公有成员** | 公有成员（可以访问）     | 保护成员（派生类内可以访问） | 私有成员（派生类内可以访问） |
| **保护成员** | 保护成员（可以访问）     | 保护成员（可以访问）         | 私有成员（派生类内可以访问） |
| **私有成员** | 不能访问                 | 不能访问                     | 不能访问                     |
| **外部访问** | 外部可访问公有成员       | 外部无法访问                 | 外部无法访问                 |



### **使用场景：**

* **公有继承：** 是最常见的继承方式，通常用于表示“是一个”的关系，比如一个 `Dog` 类继承自 `Animal` 类。
* **保护继承：** 较少使用，主要用于一些特殊场景下，需要在派生类中访问基类的成员，但不希望外部访问。
* **私有继承：** 常用于实现细节的封装，表示类的“实现”关系。适用于那些不需要向外暴露基类接口的情况。

### 继承关系中，基类的构造函数和析构函数如何被调用？

* **构造顺序：** 基类构造函数 → 派生类构造函数。
* **析构顺序：** 派生类析构函数 → 基类析构函数。

### 如果我们没有将基类的析构函数声明为虚函数，会有什么问题？

* 在多态中起着至关重要的作用，确保派生类的资源能够被正确清理，避免内存泄漏或资源泄漏的问题。如果基类的析构函数没有声明为虚函数，删除派生类对象时只会调用基类的析构函数，导致派生类的资源未释放，进而造成内存泄漏。

## **多态**

### 是通过 **虚函数** 和 **动态绑定** 来实现的，使得同样的接口在不同的对象上可以表现出不同的行为。

## 虚函数（Virtual Function）

虚函数是基类中声明为 `virtual` 的函数。它的目的是为了实现​**动态多态性**​。通过虚函数，程序可以在运行时根据实际对象的类型来调用对应的函数，而不是仅仅根据指针或引用的类型来决定调用哪个函数。

* ​**声明**​：在基类中声明为 `virtual`，如果派生类需要重写它，应该使用 `override` 关键字来表示。
* ​**工作原理**​：当通过基类指针或引用调用虚函数时，程序会使用**动态绑定**机制，在运行时查找并调用对应的派生类实现
* **为什么需要虚函数？**：虚函数的目的是实现​**多态，也就是同一个函数调用可以根据不同的对象类型（基类或派生类）做出不同的行为。** 没有虚函数，基类指针或者引用将只能调用基类的方法，而无法调用派生类中重写的方法，失去了多态的效果。
* 通过 ​**虚函数**​，在运行时会根据对象的实际类型来决定调用哪个版本的函数，而不是编译时决定。这就实现了动态绑定。

### 纯虚函数

纯虚函数是虚函数的一种特殊形式，用于在基类中声明一个接口。纯虚函数的目的是让派生类必须实现该函数，不能在基类中给出实现。

* ​**声明**​：纯虚函数在基类中声明为虚函数，并且函数体使用 `= 0` 来标记。
* ​**目的**​：通过定义纯虚函数，基类变成了一个抽象类（Abstract Class）。抽象类不能实例化，只能通过派生类来实现。


### 虚继承
虚继承是 C++ 中的一种机制，用于**解决多重继承中的菱形继承问题**。在菱形继承中，继承多个从同一个类派生而来的基类，会导致派生类中包含多个基类的副本，这可能会导致资源浪费和二义性问题。

* ​**声明**​：在派生类中使用 `virtual` 关键字来声明虚继承。
* ​**工作原理**​：虚继承通过在派生类中引入一个虚基类指针，使得派生类共享同一个基类实例，从而避免了菱形继承的问题。

## 异常处理机制

* C++ 的异常处理机制是通过 `try`、`catch` 和 `throw` 来实现的。程序中当发生错误时，异常被抛出，`catch` 块捕获并处理这些异常。异常处理能够使得程序在发生错误时仍然能够优雅地退出或处理错误，而不是崩溃。

## C++ 中 `new` 和 `malloc` 有什么区别？

* **`malloc`** 不会抛出异常，如果分配失败，它会返回 `NULL`，需要手动检查。

* **`new`** 如果分配失败，默认会抛出异常（`std::bad_alloc`），但可以使用 `new(std::nothrow)` 来避免异常，返回 `nullptr`。
* **`malloc`** 适合于 C 风格的内存分配，**`new`** 更加符合 C++ 对象的内存管理需求。**

## 为什么需要 `explicit`？

* explicit 关键字用于防止构造函数用于隐式类型转换，确保对象的创建是显式且明确的。这有助于避免类型转换带来的意外行为或潜在的错误。

* 隐式类型转换是指当你尝试将一个类型的对象赋值给另一个类型的变量时，编译器自动调用构造函数或转换操作来完成类型转换。

